"""
 Title: structures.py

  Author:  Peter Row, peter.row@ga.gov.au
           Duncan Gray, duncan.gray@ga.gov.au

  Description: Classes and functions for holding structure information.

  Version: $Revision: 1716 $
  ModifiedBy: $Author: rwilson $
  ModifiedDate: $Date: 2010-06-18 13:58:01 +1000 (Fri, 18 Jun 2010) $

  Copyright 2007 by Geoscience Australia
"""


from scipy import alltrue, in1d, newaxis, unique, where, zeros

# based on;
# http://stackoverflow.com/questions/5614741/cant-use-a-list-of-methods-in-a-python-class-it-breaks-deepcopy-workaround
import copy
import types

def _deepcopy_method(x, memo):
    return type(x)(x.im_func, copy.deepcopy(x.im_self, memo), x.im_class)
copy._deepcopy_dispatch[types.MethodType] = _deepcopy_method

from eqrm_code.csv_interface import csv_to_arrays
from eqrm_code.sites import Sites
from eqrm_code.vulnerability_model import Vulnerability_Set
from eqrm_code.util import find_period_indices

attribute_conversions = {'LATITUDE': float,
                         'LONGITUDE': float,
                         'STRUCTURE_CLASSIFICATION': str,
                         'BUILDING_COST_DENSITY': float,
                         'FLOOR_AREA': float,
                         'SURVEY_FACTOR': float,
                         'POSTCODE': int,
                         'SUBURB': str,
                         'BID': int,
                         'SITE_CLASS': str}


class Structures_Vulnerability(Sites):

    def __init__(self, 
                 latitude, 
                 longitude, 
                 vulnerability_set,
                 **attributes):
        """Create an object holding all Structures data for user defined 
        vulnerability curves
        """

        # inherit setup from Sites, add building parameters
        Sites.__init__(self, latitude, longitude, **attributes)
        self.vulnerability_set = vulnerability_set
        
        # Validate that the curves match this set
        self.validate_vulnerability_set()


    @classmethod
    def from_csv(cls, sites_filename, eqrm_flags):
        """Read structures data from a file.
        Extract structure parameters from building_parameters_table.

        parameters
          sites_filename is actually a file handle
        """
        
        sites_dict = csv_to_arrays(sites_filename, **attribute_conversions)
        
        latitude = sites_dict.pop("LATITUDE")
        longitude = sites_dict.pop("LONGITUDE")
        
        # create copy of attributes
        attributes = copy.copy(sites_dict)
        
        # Create the vulnerability curves
        vulnerability_set = Vulnerability_Set.from_xml(eqrm_flags)
        
        # create structures:
        return cls(latitude, longitude, vulnerability_set, **attributes)

    
    def validate_vulnerability_set(self):
        """The vulnerability set must provide curves for all sites in this
        object. A Vulnerability_Function needs to be defined to match each
        attributes['STRUCTURE_CLASSIFICATION'] identifier.
        
        Raises a RuntimeError if it cannot find a match.
        """
        if self.vulnerability_set is None:
            raise RuntimeError('Vulnerability Set must not be None')
        
        # Function IDs for the vulnerability set
        curves_defined = self.vulnerability_set.vulnerability_functions.keys()
        
        # Sites STRUCTURE_CLASSIFICATIONs
        structure_classifications = self.attributes['STRUCTURE_CLASSIFICATION']
        structure_classifications = unique(structure_classifications)
        
        # Are there any unique structure classifications that are not in the 
        # curves defined?
        in_curves_defined = in1d(structure_classifications, curves_defined)
        if not alltrue(in_curves_defined):
            msg = 'The following structures do not have a vulnerability curve: '
            msg += '%s' % structure_classifications[where(in_curves_defined == False)]
            raise RuntimeError(msg)
        
        

    def calc_loss(self, SA, atten_periods):
        """
        Calculate the economic loss at a site for a user defined vulnerability
        curve. 
        
        The curve data should be loaded in with the analysis function
        load_data() and self.vulnerability_set defined. If it hasn't and this 
        function is called a runtime error is thrown.
        
        SA                 array of Spectral Acceleration, in g, with axis;
                               sites, psudo_events, periods
                           the site axis usually has a size of 1
        
        Returns economic_loss where:
          economic_loss    A dollar loss, with the the dimensions of;
                           (site, event)
        """
        
        if self.vulnerability_set is None:
            raise RuntimeError('Vulnerability set not found')
        
        # Only send the SA at this period, when converting to MMI
        period = 1.0
        periods_indexs = find_period_indices(atten_periods, 
                                             wanted_periods = [period],
                                             epsilon=1.0e-3)
               
        # Calculate intensity measure level
        SA_1_sec = SA[...,periods_indexs[period]]
        IML = self.vulnerability_set.intensity_conversion(SA_1_sec,
                                                          period = 1.0)
        
        # Get mean and sigma for this measure level and site type
        mean_loss = zeros(IML.shape)
        sigma = zeros(IML.shape)
        for i, func_id in enumerate(self.attributes['STRUCTURE_CLASSIFICATION']): 
            (mean_loss[i,:], 
             sigma[i,:]) = self.vulnerability_set.calc_mean(func_id, IML[i,:])
        
        # Get the loss_ratio by taking a random sample
        loss_ratio = self.vulnerability_set.sample(func_id, mean_loss, sigma)
        
        # Perform a cutoff for the ratio limits
        loss_ratio = self.vulnerability_set.ratio_cutoff(loss_ratio)
        
        # Economic loss factors
        # We want these to have the same axes as IML
        bcd = self.attributes['BUILDING_COST_DENSITY'][:,newaxis]
        fa = self.attributes['FLOOR_AREA'][:,newaxis]
        sf = self.attributes['SURVEY_FACTOR'][:,newaxis]
        
        # Calculate economic loss
        economic_loss = bcd * fa * sf * loss_ratio
        # economic_loss shape (sites, pseudo_events)
        return economic_loss

    def __getitem__(self, key):
        """Get single indexed entry from a Structures object."""
        
        # if 'key' is naked int, make a list
        if isinstance(key, int):
            key = [key]

        # get indexed .attributes
        attributes = {}
        for k in self.attributes.keys():
            attributes[k] = self.attributes[k][key]

        # copy the existing vulnerability set
        vulnerability_set = copy.deepcopy(self.vulnerability_set)

        # create shiny new Structures object with this single structure
        return Structures_Vulnerability(self.latitude[key], 
                                        self.longitude[key],
                                        vulnerability_set, 
                                        **attributes)
