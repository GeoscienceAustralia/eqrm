"""
 Title: vulnerability_model.py
 
  Author:   Ben Cooper, ben.cooper@ga.gov.au
             
  Description: TODO: 
  
  Copyright 2012 by Geoscience Australia
"""

from eqrm_code.xml_interface import Xml_Interface
from eqrm_code.ground_motion_distribution import *
from eqrm_code.RSA2MMI import rsa2mmi_array

import os
from scipy import asarray, interp, where

class Vulnerability_Set(object):
    """
    A set of vulnerability functions for a given intensity measure level.
    
    Methods:
    - calc_mean - return mean loss and sigma for the given function id
    - sample - return a sample for the given function id
    - intensity_conversion - conversion function from SA to specified intensity
      measure type (currently conversion to MMI is only supported)
    
    Constructor input:
    - intensity_measure_level - a set of points for the x axis of the mean loss
      curve (common to all functions)
    - intensity_measure_type - type of intensity measure that the intensity 
      measure level specifies ('MMI' is the only supported value)
    - vulnerability_functions - a dictionary of Vulnerability_Function objects
      where the function id is the key 
    
    Class method:
    - from_xml - construct a Vulnerability_Set object from a NRML vulnerability
      file
    """
    
    def __init__(self,
                 intensity_measure_level,
                 intensity_measure_type,
                 vulnerability_functions):
        self.intensity_measure_level = asarray(intensity_measure_level)
        
        self.intensity_measure_type = intensity_measure_type
        if self.intensity_measure_type == 'MMI':
            self.intensity_conversion = rsa2mmi_array
        else:
            raise NotImplementedError(
                '%s is not a supported intensity measure type' % intensity_measure_type)
        
        self.vulnerability_functions = vulnerability_functions
        
    @classmethod
    def from_xml(cls, eqrm_flags):
        """
        Load a GEM NRML vulnerability file in the format described in 
        resources/nrml/schema/risk/vulnerability.xsd
        
        e.g.
        
        <discreteVulnerabilitySet vulnerabilitySetID="HAZUS" assetCategory="buildings" lossCategory="economic_loss">
          <IML IMT="MMI"> 0.00 5.27 6.15 6.67 7.04 7.33 7.56 7.76 7.93 8.08 8.22 8.34 8.45 8.58 8.67 8.76 8.84 8.91 8.99 9.05 9.12 9.18 9.24 9.30 9.35 9.40 9.45 9.50 9.55 9.59 9.63 9.68 9.72 9.75 9.79 9.83 9.87 9.90 9.94 9.98 10.0</IML>
          <discreteVulnerability vulnerabilityFunctionID="W1TIMBERMETAL" probabilisticDistribution="LN">
            <lossRatio> 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.01 0.02 0.03 0.04 0.06 0.08 0.10 0.13 0.15 0.18 0.21 0.24 0.27 0.31 0.34 0.37 0.40 0.43 0.46 0.49 0.52 0.55 0.58 0.60 0.63 0.65 0.67 0.70 0.72 1.00</lossRatio>
            <coefficientsVariation> 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30</coefficientsVariation>
          </discreteVulnerability>
          <discreteVulnerability vulnerabilityFunctionID="W1BVMETAL" probabilisticDistribution="LN">
            <lossRatio> 0.00 0.04 0.15 0.25 0.34 0.42 0.49 0.55 0.60 0.64 0.67 0.71 0.73 0.76 0.78 0.80 0.81 0.83 0.84 0.85 0.87 0.87 0.88 0.89 0.90 0.91 0.91 0.92 0.92 0.93 0.93 0.94 0.94 0.94 0.95 0.95 0.95 0.95 0.96 0.96 1.00</lossRatio>
            <coefficientsVariation> 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30 0.30</coefficientsVariation>
          </discreteVulnerability>
        </discreteVulnerabilitySet>
        
        This function looks for the file in 
        <eqrm_flags.input_dir>/<eqrm_flags.site_tag>_vulnerability.xml
        
        TODO: no XSD validation is currently performed. This requires lxml,
        which is not available in GA's runtime environment currently.
        """
        
        # Find location of site database (i.e. building database) and get FID
        filename = os.path.join(eqrm_flags.input_dir, 
                                '%s_vulnerability.xml' % eqrm_flags.site_tag)
        if not os.path.exists(filename):
            msg = "No vulnerability XML was loaded. Check file name " + filename
            raise RuntimeError(msg) 
            
        doc = Xml_Interface(filename=filename)
        
        vulnerability_set = doc['discreteVulnerabilitySet'][0]
        
        IML = vulnerability_set['IML'][0]
        intensity_measure_level = IML.array[0]
        intensity_measure_type = IML.attributes['IMT']
        
        vulnerabilities = vulnerability_set['discreteVulnerability']
        vulnerability_functions = {}
        for func in vulnerabilities:
            func_id = func.attributes['vulnerabilityFunctionID']
            prob_dist = func.attributes['probabilisticDistribution']
            loss_ratio = func['lossRatio'][0].array[0]
            coefficient_of_variation = func['coefficientsVariation'][0].array[0]
            var_method = eqrm_flags.vulnerability_variability_method
            
            vulnerability_functions[func_id] = Vulnerability_Function(func_id,
                                                    loss_ratio,
                                                    coefficient_of_variation,
                                                    prob_dist,
                                                    var_method)
        
        return cls(intensity_measure_level,
                   intensity_measure_type,
                   vulnerability_functions)

    def __repr__(self):
        return ('Discrete Vulnerability Set:\n'
                '          intensity measure type: %s\n'
                '         intensity measure level: %s\n'
                'discrete vulnerability functions: %s\n'
                % (str(self.intensity_measure_type),
                   str(self.intensity_measure_level),
                   str(self.vulnerability_functions.keys())))

    def calc_mean(self, func_id, intensity):
        """
        A wrapper for Vulnerability_Function.calc_mean. Lookup the specified
        vulnerability function in the set and run calc_mean for that function.
        """
        func = self.vulnerability_functions.get(func_id)
        if func is None:
            raise NotImplementedError(
                '%s does not have a configured vulnerability curve' % func_id)
        
        return func.calc_mean(intensity, self.intensity_measure_level)
    
    def sample(self, func_id, mean, sigma):
        """
        A wrapper for Vulnerability_Function.sample. Lookup the specified
        vulnerability function in the set and run sample for that function.
        """
        func = self.vulnerability_functions.get(func_id)
        if func is None:
            raise NotImplementedError(
                '%s does not have a configured vulnerability curve' % func_id)
        
        return func.sample(mean, sigma)
    
    def ratio_cutoff(self, ratio):
        """
        As Vulnerability_Function.sample may return values outside of a ratio,
        ensure that the given ratio array is between 0 and 1 by setting values
        outside these bounds to the bounds.
        """
        # High cutoff
        ratio = where(ratio > 1.0, 1.0, ratio)
        # Low cufoff
        ratio = where(ratio < 0.0, 0.0, ratio)
        
        return ratio
    

class Vulnerability_Function(object):
    """
    A vulnerability function defined by a specified set of points on a curve.

    Methods:
    - calc_mean - return mean loss and sigma based on the given set of points
    - sample - return a sample based on the specified probabilistic distribution
    
    Constructor input:
    - func_id - identifier for this function
    - mean_loss_ratio - array of ratio points
    - coefficient_of_variation - array of uncertainty points (shape must match 
      shape of mean_loss_ratio)
    - distribution - either normal ('N') or lognormal ('LN')
    - var_method - variability method to be used in sampling (see sample doc)
    """
    
    def __init__(self, 
                 func_id,
                 mean_loss_ratio, 
                 coefficient_of_variation,
                 distribution,
                 var_method=2):
        self.function_id = func_id
        self.mean_loss_ratio = asarray(mean_loss_ratio)
        self.coefficient_of_variation = asarray(coefficient_of_variation)
        
        # Support lognormal and normal only initially 
        # (this could be covered in xsd validation)
        if distribution == 'N':
            self.distribution = Distribution_Normal(var_method=var_method)
        elif distribution == 'LN':
            self.distribution = Distribution_Log_Normal(var_method=var_method)
        else:
            raise NotImplementedError(
                '%s: %s is not a supported probabilistic distribution' % (func_id,
                                                                          distribution))
    
    def calc_mean(self, intensity, intensity_measure_level):
        """
        Calculate mean loss ratio and sigma based on the specified points on 
        the curve:
                        |
                        |                                +
                        |                           +
        Mean loss ratio |                     +
                        |               +
                        |            +
                        |          +
                        |         +
                        |        +
                        |       +
                        |    +
                        | +
                        +-----------------------------------
                               Intensity measure level
        
        For a given intensity, mean loss and sigma is determined by linearly
        interpolating the points on the curve.
        
        Note that sigma is calculated as cv * mean loss as cv = mean loss/sigma
        """
        mean_loss = interp(intensity, 
                           intensity_measure_level, 
                           self.mean_loss_ratio)
        cv = interp(intensity, 
                    intensity_measure_level, 
                    self.coefficient_of_variation)
        # cv = sigma / mean
        sigma = cv * mean_loss
        
        return (mean_loss, sigma)
    
    def sample(self, mean, sigma):
        """
        Take a sample based on the given mean and sigma. The distribution used
        is either normal or lognormal, and based on the specified variability
        method:
        
        None -> no sampling (mean loss is the deterministic figure)
        2 -> random sampling
        3 -> mean + 2 * sigma
        4 -> mean + sigma
        5 -> mean - sigma
        6 -> mean - 2 * sigma
        """
        return self.distribution.sample_for_eqrm(mean, sigma)
        