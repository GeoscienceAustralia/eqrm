
import unittest

from scipy import array, allclose, newaxis, arange
from eqrm_code.capacity_spectrum_functions import *
from eqrm_code.capacity_spectrum_model import Capacity_spectrum_model, \
     CSM_DAMPING_REGIMES_USE_ALL, CSM_DAMPING_MODIFY_TAV


     
def cap_curve_function(Dy,Ay,Du,Au, Sd):
    ky = (Ay/Dy) #slope of linear part of capacity curve
    cc = Au
    bb = ky/(Au-Ay)
    aa = (Ay-Au)*exp(bb*Dy)

    return cc + aa*exp(-bb*Sd)
    
    
class Test_capacity_spectrum_functions(unittest.TestCase):
    def test_undamped_response(self):
        """
        Test that the undamped response is the same as matlabs
        """
        # in:
        # This info is generated by a ground motion model
        t_all=array([0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,
                     1.5,2,2.5,3,3.5,4,4.5,5])
        SA=array([0.342010,0.763370,0.653840,0.530630,0.44294,
                  0.38397,0.34452,0.321240,0.302940,0.276640,
                  0.248310,0.15958,0.11005,0.080179,0.055094,
                  0.039724,0.029105,0.021409,0.015748])
        SA.shape=1,1,-1

        aus_mag=array([7.2])
        
        SA,SD=undamped_response(SA,t_all)
        TAV,TVD=calculate_corner_periods(t_all,SA,aus_mag)
 
        # out (from matlab)
        TAV_mat=0.46795
        TVD_mat=12.589
        SD_mat=[0,1.895,6.4923,11.855,17.593,23.829,30.789,39.074,48.129,
                55.625,61.64,89.128,109.27,124.4,123.09,120.8,115.6,107.62,
                97.732]
        assert allclose(TAV_mat,TAV,rtol=5e-5)
        assert allclose(TVD_mat,TVD,rtol=5e-5)
        assert allclose(SD,SD_mat,rtol=5e-5)        

    def test_sample_capacity_parameters_no_variability(self):
        # The mean and sigma can be anything so we'll ignore the setup values

        C = array([0.2])
        C_sigma = array([0.3])
        T = array([0.2])
        T_sigma = array([0.3])
        a1 = array([0.8])
        a1_sigma = array([0.3])
        a2 = array([0.8])
        a2_sigma = array([0.3])
        y = array([1.5])
        y_sigma = array([0.3])
        Lambda = array([2.5])
        Lambda_sigma = array([0.3])
        u = array([4.])
        u_sigma = array([0.3])
        
        csm_variability_method = None
        
        C,T,a1,a2,y,Lambda,u = sample_capacity_parameters(C,C_sigma,
                                                          T,T_sigma,
                                                          a1,a1_sigma,
                                                          a2,a2_sigma,
                                                          y,y_sigma,
                                                          Lambda,Lambda_sigma,
                                                          u,u_sigma,
                                                          csm_variability_method)

        # Expected values
        C_expected = array([0.2])
        T_expected = array([0.2])
        a1_expected = array([0.8])
        a2_expected = array([0.8])
        y_expected = array([1.5])
        Lambda_expected = array([2.5])
        u_expected = array([4.])

        msg = "Expected: %s, Got: %s"

        self.assert_(C_expected == C, 
                     msg % (C_expected, C))
        self.assert_(T_expected == T, 
                     msg % (T_expected, T))
        self.assert_(a1_expected == a1, 
                     msg % (a1_expected, a1))
        self.assert_(a2_expected == a2, 
                     msg % (a2_expected, a2))
        self.assert_(y_expected == y, 
                     msg % (y_expected, y))
        self.assert_(Lambda_expected == Lambda, 
                     msg % (Lambda_expected, Lambda))
        self.assert_(u_expected == u, 
                     msg % (u_expected, u))
        
    def run_sample_capacity_parameters_sigmas(self, var_method, sigma_op):

        C_input = array([0.2])
        C_sigma = array([0.3])
        T_input = array([0.2])
        T_sigma = array([0.3])
        a1_input = array([0.8])
        a1_sigma = array([0.3])
        a2_input = array([0.8])
        a2_sigma = array([0.3])
        y_input = array([1.5])
        y_sigma = array([0.3])
        Lambda_input = array([2.5])
        Lambda_sigma = array([0.3])
        u_input = array([4.])
        u_sigma = array([0.3])
        
        C,T,a1,a2,y,Lambda,u = sample_capacity_parameters(
                                                    C_input,C_sigma,
                                                    T_input,T_sigma,
                                                    a1_input,a1_sigma,
                                                    a2_input,a2_sigma,
                                                    y_input,y_sigma,
                                                    Lambda_input,Lambda_sigma,
                                                    u_input,u_sigma,
                                                    var_method)

        # Expected values
        C_expected = C_input + sigma_op * C_sigma
        T_expected = T_input + sigma_op * T_sigma
        a1_expected = a1_input + sigma_op * a1_sigma
        a2_expected = a2_input + sigma_op * a2_sigma
        y_expected = y_input + sigma_op * y_sigma
        Lambda_expected = Lambda_input + sigma_op * Lambda_sigma
        u_expected = u_input + sigma_op * u_sigma
        
        msg = "Expected: %s, Got: %s"

        self.assert_(C_expected == C, 
                     msg % (C_expected, C))
        self.assert_(T_expected == T, 
                     msg % (T_expected, T))
        self.assert_(a1_expected == a1, 
                     msg % (a1_expected, a1))
        self.assert_(a2_expected == a2, 
                     msg % (a2_expected, a2))
        self.assert_(y_expected == y, 
                     msg % (y_expected, y))
        self.assert_(Lambda_expected == Lambda, 
                     msg % (Lambda_expected, Lambda))
        self.assert_(u_expected == u, 
                     msg % (u_expected, u))
        
    def test_sample_capacity_parameters_sigmas(self):
        
        # csm_variability_method 3 -> +2*sigma
        var_method = 3
        sigma_op = 2
        self.run_sample_capacity_parameters_sigmas(var_method, sigma_op)
        
        # csm_variability_method 4 -> +sigma
        var_method = 4
        sigma_op = 1
        self.run_sample_capacity_parameters_sigmas(var_method, sigma_op)
        
        # csm_variability_method 5 -> -sigma
        var_method = 5
        sigma_op = -1
        self.run_sample_capacity_parameters_sigmas(var_method, sigma_op)
        
        # csm_variability_method 6 -> -2*sigma
        var_method = 6
        sigma_op = -2
        self.run_sample_capacity_parameters_sigmas(var_method, sigma_op)

    def test_capacity_parameters(self):
        """
        Test that capacity parameters and kappa are the same as matlabs
        """
        
        # in:
        params=0.069,13,0.3,0.9,0.7,1.75,2,7
        dparams=(0.001,0.001,0.001,0.08)
        dparams=[array(p) for p in dparams]
        C,height,T,a1,a2,y,h,u=params
        magnitude=array([7.2])
        damping_s,damping_m,damping_l,B0=dparams
        
        alpha, beta, delta, theta = 0.4, 0.6, 0.8, 1.0
        
        # C=design_strength
        # T=natural_elastic_period
        # a1=fraction_in_first_mode
        # a2=height_to_displacement
        # y=yield_to_design
        # h=ultimate_to_yield
        # u=ductility
        # alpha=degrading alpha
        # beta=degrading beta
        # delta=degrading delta
        # theta=degrading theta
        
        capacity_parameters=calculate_capacity_parameters(C,T,a1,a2,y,h,u,
                                                          alpha,beta,
                                                          delta,theta)
        (Dy, Ay,
         Du, Au, 
         Du_alpha, Au_rev,
         Du_beta, Au_rev_0_8,
         Du_delta, Au_rev_0_2,
         Du_theta, Au_rev_0_1,
         aa, bb, cc) = capacity_parameters
        kappa=calculate_kappa(magnitude,damping_s,damping_m,damping_l)

        # out:
        Aym,Dym,Aum,Dum=(0.13417,2.9975,0.26833,41.964)
        aam,bbm,ccm,kappam=(-0.3647,0.33362,0.26833,0.001)

        # Du_alpha = alpha*Du
        # Du_beta = beta*Du
        # Du_delta = delta*Du
        # Du_theta = theta*Du
        Du_alpha_m = Dum * alpha
        Du_beta_m = Dum * beta
        Du_delta_m = Dum * delta
        Du_theta_m = Dum * theta
        
        # Au_rev = = a*exp(Du_alpha*-b)+c
        # Au_rev_0_8 = 0.8*Au_rev
        # Au_rev_0_2 = 0.2*Au_rev
        # Au_rev_0_1 = 0.1*Au_rev
        Au_rev_m = aam * exp(Du_alpha_m*-bbm)+ccm
        Au_rev_0_8_m = 0.8*Au_rev_m
        Au_rev_0_2_m = 0.2*Au_rev_m
        Au_rev_0_1_m = 0.1*Au_rev_m
        
        assert allclose((Dy,Ay,Du,Au,aa,bb,cc),
                        (Dym,Aym,Dum,Aum,aam,bbm,ccm),
                        rtol=5e-5)
        assert allclose(kappa,kappam)
        assert allclose((Du_alpha, Du_beta, Du_delta, Du_theta),
                        (Du_alpha_m, Du_beta_m, Du_delta_m, Du_theta_m),
                        rtol=5e-5)
        assert allclose((Au_rev, Au_rev_0_8, Au_rev_0_2, Au_rev_0_1),
                        (Au_rev_m, Au_rev_0_8_m, Au_rev_0_2_m, Au_rev_0_1_m),
                        rtol=5e-5)

    def test_build_capacity(self):
        """
        Test that the capacity is the same as matlabs
        """
        surface_displacement=array([0,1.895,6.4923,11.855,17.593,23.829,
                                    30.789,39.074,48.129,55.625,61.64,
                                    89.128,109.27,124.4,123.09,120.8,
                                    115.6,107.62,97.732])
        
        surface_displacement.shape=1,1,-1                
        
        Ay,Dy,Au,Du=(0.13417,2.9975,0.26833,41.964)
        aa,bb,cc,kappa=(-0.3647,0.33362,0.26833,0.001)
        # TODO: Fix test data once capacity curve switched to degrading
        Du_alpha,Au_rev=(0,0)
        Du_beta,Au_rev_0_8=(0,0)
        Du_delta,Au_rev_0_2=(0,0)
        Du_theta,Au_rev_0_1=(0,0)
        capacity_parameters=(Dy,Ay,
                             Du,Au,
                             Du_alpha,Au_rev,
                             Du_beta,Au_rev_0_8,
                             Du_delta,Au_rev_0_2,
                             Du_theta,Au_rev_0_1,
                             aa,bb,cc)     
        capacity_parameters=array(capacity_parameters)[:,newaxis,newaxis,newaxis]
        capacity=calculate_capacity(surface_displacement,capacity_parameters)

        #out
        capacity_m=[0,0.084818,0.22652,0.26135,0.2673,0.2682,0.26832,
                    0.26833,0.26833,0.26833,0.26833,0.26833,0.26833,
                    0.26833,0.26833,0.26833,0.26833,0.26833,0.26833]

        assert allclose(capacity[0],capacity_m,rtol=5e-5)        
         

    def test_build_capacityIII(self):
        """
        Warning this test is not based on what should be happening,
        rather it is based on what seems reasonable.

        It is to cover the second bit of weaved code.
        """
        surface_displacement=array([0,1.895])
        
        surface_displacement.shape=1,2,-1                
        
        Ay,Dy,Au,Du=(0.13417,2.9975,0.26833,41.964)
        aa,bb,cc,kappa=(-0.3647,0.33362,0.26833,0.001)
        # TODO: Fix test data once capacity curve switched to degrading
        Du_alpha,Au_rev=(0,0)
        Du_beta,Au_rev_0_8=(0,0)
        Du_delta,Au_rev_0_2=(0,0)
        Du_theta,Au_rev_0_1=(0,0)
        capacity_parameters=(Dy,Ay,
                             Du,Au,
                             Du_alpha,Au_rev,
                             Du_beta,Au_rev_0_8,
                             Du_delta,Au_rev_0_2,
                             Du_theta,Au_rev_0_1,
                             aa,bb,cc)      
        capacity_parameters=array(capacity_parameters)[:,newaxis,newaxis,newaxis]
        capacity=calculate_capacity(surface_displacement,capacity_parameters)

        #out
        capacity_m=array([0,0.084818])
        capacity_m.shape = 1,2,-1  
        #print "capacity", capacity
        assert allclose(capacity[0],capacity_m,rtol=5e-5)        
        
    def test_calculate_capacity_degrading_python(self):
        """
        Test the degrading capacity curve function implemented in pure python
        works as expected
        """
        
        # Set up variables
        surface_displacement=array([0.0,  # edge
                                    0.5,  # linear region
                                    1.0,  # edge
                                    1.5,  # exponential region
                                    20.0, # edge
                                    20.5, # first degrading region
                                    21.0, # edge
                                    21.5, # second degrading region
                                    22.0, # edge
                                    22.5, # third degrading region
                                    23.0, # edge
                                    23.5, # flat region
                                    ])    
        
        Ay,Dy,Au,Du=(1,1,2,20)
        a,b,c = (-2.7182818284590451,1,2)
        Du_alpha,Au_rev=(20,2)
        Du_beta,Au_rev_0_8=(21,1.6)
        Du_delta,Au_rev_0_2=(22,0.4)
        Du_theta,Au_rev_0_1=(23,0.2)
        
        capacity_parameters=(Dy,Ay,
                             Du,Au,
                             Du_alpha,Au_rev,
                             Du_beta,Au_rev_0_8,
                             Du_delta,Au_rev_0_2,
                             Du_theta,Au_rev_0_1,
                             a,b,c)      
        capacity_parameters=array(capacity_parameters)[:,newaxis,newaxis,newaxis]
        
        capacity=calculate_capacity_degrading_python(surface_displacement,
                                                     capacity_parameters)
        
        expected_capacity = array([0.0,             # edge
                                   0.5,             # linear region
                                   1.0,             # edge
                                   a*exp(1.5*-b)+c, # exponential region
                                   2.0,             # edge
                                   (2.0+1.6)/2,     # first degrading region
                                   1.6,             # edge
                                   (1.6+0.4)/2,     # second degrading region
                                   0.4,             # edge
                                   (0.4+0.2)/2,     # third degrading region
                                   0.2,             # edge
                                   0.2,             # flat region
                                   ])
        
        assert allclose(capacity, expected_capacity, rtol=5e-5)   
        
    def test_update_demand(self):
        """
        Test that the  reduction factors and update damand functions
        work the same as matlab
        """

        #in
        SA=array([0.342010,0.763370,0.653840,0.530630,0.44294,
                  0.38397,0.34452,0.321240,0.302940,0.276640,
                  0.248310,0.15958,0.11005,0.080179,0.055094,
                  0.039724,0.029105,0.021409,0.015748])
        SA.shape=1,1,-1

        SD=array([0,1.895,6.4923,11.855,17.593,23.829,
                  30.789,39.074,48.129,55.625,61.64,
                  89.128,109.27,124.4,123.09,120.8,
                  115.6,107.62,97.732])
        SD.shape=1,1,-1
        
        TAV=array([[0.46795]])
        TVD=array([[12.589]])
        

        damping_factor=0.08
        periods=array([0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,
                     1.5,2,2.5,3,3.5,4,4.5,5])
        damp_corner_periods=True
        # calc

        Ra,Rv,Rd=calculate_reduction_factors([damping_factor])
        if damp_corner_periods: TAV=TAV*(Ra/Rv)
        Ra.shape=1,1,1
        Rv.shape=1,1,1
        Rd.shape=1,1,1
        
        SAnew,SDnew=calculate_updated_demand(
            periods,SA,SD,Ra,Rv,Rd,TAV,TVD)

        assert allclose((Ra[0,0,0],Rv[0,0,0],Rd[0,0,0]),
                        (1.1804,1.1321,1.1044),rtol=5e-5)

        SD_newm=[0,1.6053,5.5,10.043,15.058,20.826,27.195,34.514,42.512,
                 49.133,54.446,78.726,96.519,109.88,108.72,106.7,102.11,
                 95.059,86.326]
        assert allclose(SDnew,SD_newm,rtol=5e-5)

    def test_build_capacity_again(self):
        """
        Test that calculating the capacity works again.
        """
        SD_new=array([0,1.60533088580753,5.49998633698612,10.0430812761127,
                      15.05788941807,20.8257362526643,27.1952446916894,
                      34.5140821612566,42.5117576683308,49.1327918769187,
                      54.4456104247827,78.726251497955,96.5187076679668,
                      109.878354239657,108.720841961029,106.697568070816,
                      102.107240125687,95.0591053452788,86.3258461016045])
        SD_new.shape=1,1,-1                
        
        Ay,Dy,Au,Du=(0.13417,2.9975,0.26833,41.964)
        aa,bb,cc,kappa=(-0.3647,0.33362,0.26833,0.001)
        # TODO: Fix test data once capacity curve switched to degrading
        Du_alpha,Au_rev=(0,0)
        Du_beta,Au_rev_0_8=(0,0)
        Du_delta,Au_rev_0_2=(0,0)
        Du_theta,Au_rev_0_1=(0,0)
        capacity_parameters=(Dy,Ay,
                             Du,Au,
                             Du_alpha,Au_rev,
                             Du_beta,Au_rev_0_8,
                             Du_delta,Au_rev_0_2,
                             Du_theta,Au_rev_0_1,
                             aa,bb,cc)
        capacity_parameters=array(capacity_parameters)
        
        capacity_parameters=capacity_parameters[:,newaxis,newaxis,newaxis]
        
        capacity=calculate_capacity(SD_new,capacity_parameters)

        #out
        SA_capm=array([ 0,0.0718547880987331,0.210114969058595,
                        0.255544749303803,0.26593317666683,
                        0.267982944023487,0.268291483967979,
                        0.268329691827397,0.268333333333333,
                        0.268333333333333,0.268333333333333,
                        0.268333333333333,0.268333333333333,
                        0.268333333333333,0.268333333333333,
                        0.268333333333333,0.268333333333333,
                        0.268333333333333,0.268333333333333])
        assert allclose(capacity,SA_capm,rtol=5e-5)


    def test_undamped_responseII(self):
        """
        Test that the undamped response is the same as matlabs
        """
        # in:
        t_all=array([0,0.17544,0.35088,0.52632,0.70175,
                     0.87719,1.0526,1.2281,1.4035,1.5789,
                     1.7544,1.9298,2.1053,2.2807,2.4561,
                     2.6316,2.807,2.9825,3.1579,3.3333])

        SA=array([
   0.21604198097920,
   0.49383398471879,
   0.35207861448168,
   0.28146561293471,
   0.24663798021059,
   0.18607106822206,
   0.12461515892587,
   0.08879073656528,
   0.06464645061910,
   0.04893110975922,
   0.03794974804020,
   0.02998618121319,
   0.02404471425307,
   0.01947448758241,
   0.01577287001015,
   0.01292966840312,
   0.01064323885374,
   0.00876012522030,
   0.00721096310143,
   0.00593573499178])
        SA.shape=1,1,-1

        aus_mag=array([5.6])
        
        SA,SD=undamped_response(SA,t_all)
        TAV,TVD=calculate_corner_periods(t_all,SA,aus_mag)
 
        # out (from matlab)
        TAV_mat=0.36380379723189
        TVD_mat=1.99526231496888
        assert allclose(TAV_mat,TAV)
        assert allclose(TVD_mat,TVD)

    def test_capacity_parametersII(self):
        """
        Test that capacity parameters and kappa are the same as matlabs
        """
        # in:
        params=[
  0.20000000000000,
  15.00000000000000,
   0.13000000000000,
   0.75000000000000,
   0.75000000000000,
   1.50000000000000,
   2.00000000000000,
   2.00000000000000]
        dparams=(
   0.00100000000000,
   0.00100000000000,
   0.00100000000000,
   0.0500000000000
            )
        dparams=[array(p) for p in dparams]
        
        C,height,T,a1,a2,y,h,u=params
        magnitude=array([5.6])
        damping_s,damping_m,damping_l,B0=dparams
        # C=design_strength
        # T=natural_elastic_period
        # a1=fraction_in_first_mode
        # a2=height_to_displacement
        # y=yield_to_design
        # h=ultimate_to_yield
        # u=ductility
        
        # TODO: Fix once switched over
        alpha, beta, delta, theta = 0, 0, 0, 0
        
        capacity_parameters=calculate_capacity_parameters(C,T,a1,a2,y,h,u,
                                                          alpha,beta,
                                                          delta,theta)
        (Dy, Ay,
         Du, Au, 
         Du_alpha, Au_rev,
         Du_beta, Au_rev_0_8,
         Du_delta, Au_rev_0_2,
         Du_theta, Au_rev_0_1,
         aa, bb, cc) = capacity_parameters
        
        kappa=calculate_kappa(magnitude,damping_s,damping_m,damping_l)

        # out:
        Aym,Dym,Aum,Dum=(0.40000000000000,1.67808144348440,0.80000000000000,6.71232577393759)
        aam,bbm,ccm,kappam=(-1.08731273138362, 0.59591863308111,0.80000000000000,1.000000000000000e-003)
        assert allclose((Dy,Ay,Du,Au,aa,bb,cc),
                        (Dym,Aym,Dum,Aum,aam,bbm,ccm))
        assert allclose(kappa,kappam)
       

    def test_build_capacityII(self):
        """
        Test that the capacity is the same as matlabs
        """
        surface_displacement=array([
                 0,
   3.77315416609723,
  10.76027112052043,
  19.35492219305678,
  30.15026521648398,
  35.54123657393061,
  34.27393320582447,
  33.24309574336885,
  31.61082700735715,
  30.28033350490522,
  28.99562491669272,
  27.72120498849989,
  26.45537611101864,
  25.14598796310046,
  23.61941589424981,
  22.22764650672691,
  20.81732741591404,
  19.34361135133465,
  17.85074552102223,
  16.37154426563715,
            ])
        
        surface_displacement.shape=1,1,-1              
        
        Ay,Dy,Au,Du=(0.40000000000000,1.67808144348440,0.80000000000000,6.71232577393759)
        aa,bb,cc,kappa=(-1.08731273138362, 0.59591863308111,0.80000000000000,1.000000000000000e-003)
        # TODO: Fix test data once capacity curve switched to degrading
        Du_alpha,Au_rev=(0,0)
        Du_beta,Au_rev_0_8=(0,0)
        Du_delta,Au_rev_0_2=(0,0)
        Du_theta,Au_rev_0_1=(0,0)
        capacity_parameters=(Dy,Ay,
                             Du,Au,
                             Du_alpha,Au_rev,
                             Du_beta,Au_rev_0_8,
                             Du_delta,Au_rev_0_2,
                             Du_theta,Au_rev_0_1,
                             aa,bb,cc)
        capacity_parameters=array(capacity_parameters)[:,newaxis,newaxis,newaxis]
        capacity=calculate_capacity(surface_displacement,capacity_parameters)

        #out
        capacity_m=[  0,
   0.68522523139676,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000]
        
        assert allclose(capacity[0,0],capacity_m)        
        
        
    def test_update_demandII(self):
        """
        Test that the  reduction factors and update damand functions
        work the same as matlab
        """

        #in
        SA=array([
   0.21604198097920,
   0.49383398471879,
   0.35207861448168,
   0.28146561293471,
   0.24663798021059,
   0.18607106822206,
   0.12461515892587,
   0.08879073656528,
   0.06464645061910,
   0.04893110975922,
   0.03794974804020,
   0.02998618121319,
   0.02404471425307,
   0.01947448758241,
   0.01577287001015,
   0.01292966840312,
   0.01064323885374,
   0.00876012522030,
   0.00721096310143,
   0.00593573499178])
        SA.shape=1,1,-1

        SD=array([
                  0,
   3.77315416609723,
  10.76027112052043,
  19.35492219305678,
  30.15026521648398,
  35.54123657393061,
  34.27393320582447,
  33.24309574336885,
  31.61082700735715,
  30.28033350490522,
  28.99562491669272,
  27.72120498849989,
  26.45537611101864,
  25.14598796310046,
  23.61941589424981,
  22.22764650672691,
  20.81732741591404,
  19.34361135133465,
  17.85074552102223,
  16.37154426563715,
            ])
        SD.shape=1,1,-1
        
        TAV=array([[0.36380379723189]])
        TVD=array([[1.99526231496888]])

        damping_factor=0.05
        periods=array([0,0.17544,0.35088,0.52632,0.70175,
                     0.87719,1.0526,1.2281,1.4035,1.5789,
                     1.7544,1.9298,2.1053,2.2807,2.4561,
                     2.6316,2.807,2.9825,3.1579,3.3333])
        damp_corner_periods=True
        # calc

        Ra,Rv,Rd=calculate_reduction_factors([damping_factor])
        if damp_corner_periods: TAV=TAV*(Ra/Rv)
        Ra.shape=1,1,1
        Rv.shape=1,1,1
        Rd.shape=1,1,1
        
        SAnew,SDnew=calculate_updated_demand(
            periods,SA,SD,Ra,Rv,Rd,TAV,TVD)

        #assert allclose((Ra,Rv,Rd),(1.1804,1.1321,1.1044),rtol=5e-5)

        SD_newm=[                  0,
   3.76529144594185,
  10.74365720211030,
  19.34596966933508,
  30.15264902257182,
  35.54404661276463,
  34.27664304635302,
  33.24572408157558,
  31.61332629156976,
  30.28272759473602,
  28.99791743208855,
  27.70011356416045,
  26.39091955498854,
  25.06370746188344,
  23.54213050856188,
  22.15491514703120,
  20.74921077892631,
  19.28031687908442,
  17.79233587369707,
  16.31797473121083]
        assert allclose(SDnew,SD_newm)

    def test_build_capacity_againII(self):
        """
        Test that calculating the capacity works again.
        """
        SD_new=array([                  0,
   3.76529144594185,
  10.74365720211030,
  19.34596966933508,
  30.15264902257182,
  35.54404661276463,
  34.27664304635302,
  33.24572408157558,
  31.61332629156976,
  30.28272759473602,
  28.99791743208855,
  27.70011356416045,
  26.39091955498854,
  25.06370746188344,
  23.54213050856188,
  22.15491514703120,
  20.74921077892631,
  19.28031687908442,
  17.79233587369707,
  16.31797473121083])
        SD_new.shape=1,1,-1                
        
        Ay,Dy,Au,Du=(0.40000000000000,1.67808144348440,0.80000000000000,6.71232577393759)
        aa,bb,cc,kappa=(-1.08731273138362, 0.59591863308111,0.80000000000000,1.000000000000000e-003)
        # TODO: Fix test data once capacity curve switched to degrading
        Du_alpha,Au_rev=(0,0)
        Du_beta,Au_rev_0_8=(0,0)
        Du_delta,Au_rev_0_2=(0,0)
        Du_theta,Au_rev_0_1=(0,0)
        capacity_parameters=(Dy,Ay,
                             Du,Au,
                             Du_alpha,Au_rev,
                             Du_beta,Au_rev_0_8,
                             Du_delta,Au_rev_0_2,
                             Du_theta,Au_rev_0_1,
                             aa,bb,cc)
        capacity_parameters=array(capacity_parameters)[:,newaxis,newaxis,newaxis]  
        capacity=calculate_capacity(SD_new,capacity_parameters)

        #out
        SA_capm=array([0,
   0.68468618759151,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.8000000000000,
   0.8000000000000,
   0.80000000000000,
   0.800000000000,
   0.8000000000000,
   0.8000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000,
   0.80000000000000])
        assert allclose(capacity,SA_capm)

    def BROKEN_test_find_intersection(self):
        # An error in the hysteresis area calc means the results
        # from Matlab are wrong.
        SA=array([
   0.21604198097920,
   0.49383398471879,
   0.35207861448168,
   0.28146561293471,
   0.24663798021059,
   0.18607106822206,
   0.12461515892587,
   0.08879073656528,
   0.06464645061910,
   0.04893110975922,
   0.03794974804020,
   0.02998618121319,
   0.02404471425307,
   0.01947448758241,
   0.01577287001015,
   0.01292966840312,
   0.01064323885374,
   0.00876012522030,
   0.00721096310143,
   0.00593573499178])
        SA.shape=1,1,-1
        periods=array([0,0.17544,0.35088,0.52632,0.70175,
                     0.87719,1.0526,1.2281,1.4035,1.5789,
                     1.7544,1.9298,2.1053,2.2807,2.4561,
                     2.6316,2.807,2.9825,3.1579,3.3333])
        magnitudes = array([5.6])


        building_parameters ={
            'height': array([ 4572.]),            
            'ultimate_to_yield': array([ 2.]),
            'design_strength': array([ 0.2]),
            'fraction_in_first_mode': array([ 0.75]),
            'natural_elastic_period': array([ 0.13]), 
            'yield_to_design': array([ 1.5]),            
            'height_to_displacement': array([ 0.75]),
            'ductility': array([ 2.]),           
            'damping_s': array([ 0.001]),
            'damping_m': array([ 0.001]),
            'damping_l': array([ 0.001]),
            'damping_Be': array([ 0.05])} 
       
        csm_hysteretic_damping='curve'
        rtol=1/100.0
        csm_damping_max_iterations=7
        sdtcap=0.3
        csm_use_variability=False
        csm_variability_method=3
        csm_variability_method=3
        atten_override_RSA_shape=0
        capacity_spectrum_model=Capacity_spectrum_model(
                 periods,
                 magnitudes,
                 building_parameters,
                 csm_damping_regimes=CSM_DAMPING_REGIMES_USE_ALL,
                 csm_damping_modify_Tav=CSM_DAMPING_MODIFY_TAV,
                 csm_damping_use_smoothing=CSM_DAMPING_USE_SMOOTHING,
                 csm_hysteretic_damping=csm_hysteretic_damping,
                 rtol=rtol,
                 csm_damping_max_iterations=csm_damping_max_iterations,
                 sdtcap=sdtcap,
                 csm_use_variability=csm_use_variability,
                 atten_override_RSA_shape=atten_override_RSA_shape,
                 csm_variability_method=csm_variability_method)
        SAcr,SDcr=capacity_spectrum_model.building_response(SA)
        #print SDcr
        #print SAcr

        assert allclose(1.99087165775938,SDcr[0,0])
        assert allclose(0.46802255489563,SAcr)

        
    def test_hyst_area_rand(self):

        Dy = DyV = 2.
        Ay = AyV = 4.
        Du = DuV = 7.
        Au = AuV = 6.5
            
        if False:
            Sd = arange(3,4.5,0.5)
            print "Sd", Sd
            Sa = cap_curve_function(Dy,Ay,Du,Au,Sd)
            print "Sa", Sa
            #Sd [ 3.   3.5  4. ]
            #Sa  [ 5.37667759  5.74701447  5.99525871

        if True:
            D = array([4.])
            A = array([6.])
            #csm_hysteretic_damping = 'parallelogram'
            #area = hyst_area_rand(D,A,DyV,AyV,DuV,AuV,csm_hysteretic_damping)
            #print "excel area", area
            
            csm_hysteretic_damping = 'curve'
            area = hyst_area_rand(D,A,DyV,AyV,DuV,AuV,csm_hysteretic_damping)
            #print "area", area
            
            # Based on a graph the area should be in this range 
            self.assert_(area > 20.)
            self.assert_(area < 24.)
            
            # The value calculated from hyst_area_rand,
            # once it was in the range.
            self.assert_(allclose(area,  array([ 23.31698721])))
            
          
    def test_hyst_area_rand3(self):

        Dy = DyV = 2.
        Ay = AyV = 3.
        Du = DuV = 10.
        Au = AuV = 6.77
            
        if False:
            Sd = arange(2, 6.1, 0.5)
            Sd = 6.
            print "Sd", Sd
            Sa = cap_curve_function(Dy,Ay,Du,Au,Sd)
            print "Sa", Sa
            # Sd 6.0
            # Sa 6.0023619414           
        if True:
            D = array([6.])
            A = array([6.])
            
            #csm_hysteretic_damping = 'parallelogram'
            #area = hyst_area_rand(D,A,DyV,AyV,DuV,AuV,csm_hysteretic_damping)
            #print "excel area3", area
            
            csm_hysteretic_damping = 'curve'
            area = hyst_area_rand(D,A,DyV,AyV,DuV,AuV,csm_hysteretic_damping)
            #print "area3", area
                    
            # Based on a graph the area should be in this range 
            self.assert_(area > 32.)
            self.assert_(area < 48.)
            # The value calculated from hyst_area_rand,
            # once it was in the range.
            self.assert_(allclose(area,  array([ 46.03064863])))
                    
                    
#-------------------------------------------------------------
if __name__ == "__main__":
    suite = unittest.makeSuite(Test_capacity_spectrum_functions,'test')
    #suite = unittest.makeSuite(Test_capacity_spectrum_functions,'test_hyst_area_rand')
    #suite = unittest.makeSuite(Test_capacity_spectrum_functions,'')
    runner = unittest.TextTestRunner()
    runner.run(suite)

