"""
 Title: vulnerability_model.py
 
  Author:   Ben Cooper, ben.cooper@ga.gov.au
             
  Description: TODO: 
  
  Copyright 2012 by Geoscience Australia
"""

from eqrm_code.xml_interface import Xml_Interface
from eqrm_code.ground_motion_distribution import *
from eqrm_code.RSA2MMI import rsa2mmi_array

from scipy import asarray, interp

class Vulnerability_Set(object):
    """
    TODO: docstring
    """
    
    def __init__(self,
                 intensity_measure_level,
                 intensity_measure_type,
                 vulnerability_functions):
        self.intensity_measure_level = asarray(intensity_measure_level)
        
        self.intensity_measure_type = intensity_measure_type
        if self.intensity_measure_type == 'MMI':
            self.intensity_conversion = rsa2mmi_array
        else:
            raise NotImplementedError(
                '%s is not a supported intensity measure type' % intensity_measure_type)
        
        self.vulnerability_functions = vulnerability_functions
        
    @classmethod
    def from_xml(cls, filename, eqrm_flags):
        """
        Load a GEM NRML vulnerability file in the format described in 
        resources/nrml/schema/risk/vulnerability.xsd
        
        TODO: no XSD validation is currently performed. This requires lxml,
        which is not available in GA's runtime environment currently.
        """
        
        doc = Xml_Interface(filename=filename)
        
        vulnerability_set = doc['discreteVulnerabilitySet'][0]
        
        IML = vulnerability_set['IML'][0]
        intensity_measure_level = IML.array[0]
        intensity_measure_type = IML.attributes['IMT']
        
        vulnerabilities = vulnerability_set['discreteVulnerability']
        vulnerability_functions = {}
        for func in vulnerabilities:
            func_id = func.attributes['vulnerabilityFunctionID']
            prob_dist = func.attributes['probabilisticDistribution']
            loss_ratio = func['lossRatio'][0].array[0]
            coefficient_of_variation = func['coefficientsVariation'][0].array[0]
            var_method = eqrm_flags.vulnerability_variability_method
            
            vulnerability_functions[func_id] = Vulnerability_Function(func_id,
                                                    loss_ratio,
                                                    coefficient_of_variation,
                                                    prob_dist,
                                                    var_method)
        
        return cls(intensity_measure_level,
                   intensity_measure_type,
                   vulnerability_functions)

    def __repr__(self):
        return ('Discrete Vulnerability Set:\n'
                '          intensity measure type: %s\n'
                '         intensity measure level: %s\n'
                'discrete vulnerability functions: %s\n'
                % (str(self.intensity_measure_type),
                   str(self.intensity_measure_level),
                   str(self.vulnerability_functions.keys())))

    def calc_mean(self, func_id, intensity):
        func = self.vulnerability_functions.get(func_id)
        if func is None:
            raise NotImplementedError(
                '%s does not have a configured vulnerability curve' % func_id)
        
        return func.calc_mean(intensity, self.intensity_measure_level)
    
    def random_sample(self, func_id, mean, sigma):
        func = self.vulnerability_functions.get(func_id)
        if func is None:
            raise NotImplementedError(
                '%s does not have a configured vulnerability curve' % func_id)
        
        return func.random_sample(mean, sigma)
    
    

class Vulnerability_Function(object):
    """
    TODO: docstring
    """
    
    def __init__(self, 
                 func_id,
                 mean_loss_ratio, 
                 coefficient_of_variation,
                 distribution,
                 var_method=2):
        self.function_id = func_id
        self.mean_loss_ratio = asarray(mean_loss_ratio)
        self.coefficient_of_variation = asarray(coefficient_of_variation)
        
        # Support lognormal and normal only initially 
        # (this could be covered in xsd validation)
        if distribution == 'N':
            self.distribution = Distribution_Normal(var_method=var_method)
        elif distribution == 'LN':
            self.distribution = Distribution_Log_Normal(var_method=var_method)
        else:
            raise NotImplementedError(
                '%s: %s is not a supported probabilistic distribution' % (func_id,
                                                                          distribution))
    
    def calc_mean(self, intensity, intensity_measure_level):
        mean_loss = interp(intensity, 
                           intensity_measure_level, 
                           self.mean_loss_ratio)
        cv = interp(intensity, 
                    intensity_measure_level, 
                    self.coefficient_of_variation)
        # cv = sigma / mean
        sigma = cv * mean_loss
        
        return (mean_loss, sigma)
    
    def random_sample(self, mean, sigma):
        return self.distribution.sample_for_eqrm(mean, sigma)
        